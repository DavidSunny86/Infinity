#include "VideoPlaybackEngine.h"
#include <cassert>

void VideoPlaybackEngine::init()
{
	// Register all formats and codecs
	av_register_all();
	// Open video file
	const char* videoFile = "F:\\My Soul, Your Beats.flv";
	if (av_open_input_file(&pFormatCtx, videoFile, NULL, 0, NULL)!=0)
		return; //Couldn't open file

	if (av_find_stream_info(pFormatCtx)<0)
		return; // Couldn't retrieve stream information(this is not media file or it is corrupted)
	
	// Dump information about file onto standard error
	dump_format(pFormatCtx, 0, videoFile, false);

	// Find the first video stream
	videoStream=-1;
	for(unsigned int i=0; i<pFormatCtx->nb_streams; i++)
		if(pFormatCtx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO)
		{
			videoStream=i;
			break;
		}
	if(videoStream==-1)
		return; // Didn't find a video stream

	for(unsigned int i=0; i<pFormatCtx->nb_streams; i++)
		if(pFormatCtx->streams[i]->codec->codec_type==CODEC_TYPE_AUDIO)
		{
			audioStream=i;
			break;
		}
	if(audioStream==-1)
		return; // Didn't find a video stream

	pAudioCodecCtx=pFormatCtx->streams[audioStream]->codec;
	// Find the decoder for the video stream
	AVCodec* pAudioCodec=avcodec_find_decoder(pAudioCodecCtx->codec_id);
	if(pAudioCodec==NULL)
		return; // Codec not found
	// Open codec
	if(avcodec_open(pAudioCodecCtx, pAudioCodec)<0)
		return; // Could not open codec
	//ffmpeg always decodes to 16 PCM
	int channels = pAudioCodecCtx->channels;
    if(channels == 1) mAudioFormat = AL_FORMAT_MONO16;
    if(channels == 2) mAudioFormat = AL_FORMAT_STEREO16;
    /*fucking extension - what to do if unsupported??? How to convert???*/
	if(alIsExtensionPresent("AL_EXT_MCFORMATS"))
    {
        if(channels == 4) mAudioFormat = alGetEnumValue("AL_FORMAT_QUAD16");
        if(channels == 6) mAudioFormat = alGetEnumValue("AL_FORMAT_51CHN16");
    }

	// Get a pointer to the codec context for the video stream
	pVideoCodecCtx=pFormatCtx->streams[videoStream]->codec;
	// Find the decoder for the video stream
	AVCodec* pVideoCodec=avcodec_find_decoder(pVideoCodecCtx->codec_id);
	if(pVideoCodec==NULL)
		return; // Codec not found
	// Open codec
	if(avcodec_open(pVideoCodecCtx, pVideoCodec)<0)
		return; // Could not open codec
	// Hack to correct wrong frame rates that seem to be generated by some 
	// codecs
	// if(pVideoCodecCtx->frame_rate>1000 && pVideoCodecCtx->frame_rate_base==1)
	//    pVideoCodecCtx->frame_rate_base=1000;

	// Allocate video frame
	pFrame=avcodec_alloc_frame();
	// Allocate an AVFrame structure
	pFrameRGB=avcodec_alloc_frame();
	if(pFrameRGB==NULL)
		return;

	// Determine required buffer size and allocate buffer
	numBytes=avpicture_get_size(PIX_FMT_RGB24, pVideoCodecCtx->width,
		pVideoCodecCtx->height);
	buffer=new uint8_t[numBytes];

	// Assign appropriate parts of buffer to image planes in pFrameRGB
	avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,
		pVideoCodecCtx->width, pVideoCodecCtx->height);

	timeBase = av_q2d(pFormatCtx->streams[videoStream]->time_base);

	width = pVideoCodecCtx->width;
	height = pVideoCodecCtx->height;
	srcFormat = pVideoCodecCtx->pix_fmt;
	dstFormat = PIX_FMT_RGB24;
	img_convert_ctx = sws_getContext(width, height, srcFormat, 
		width, height, dstFormat, SWS_BICUBIC, NULL, NULL, NULL);
}

void VideoPlaybackEngine::cleanup()
{
	sws_freeContext(img_convert_ctx);
	// Free the RGB image
	delete [] buffer;
	av_free(pFrameRGB);

	// Free the YUV frame
	av_free(pFrame);

	// Close the codec
	avcodec_close(pAudioCodecCtx);
	avcodec_close(pVideoCodecCtx);

	// Close the video file
	av_close_input_file(pFormatCtx);
}

void VideoPlaybackEngine::updateGLTexture(GLuint texture)
{
	int realWidth = pFrameRGB->linesize[0];
	
	sws_scale(img_convert_ctx, pFrame->data, pFrame->linesize, 0, 
				height, pFrameRGB->data, pFrameRGB->linesize);

	glBindTexture(GL_TEXTURE_2D, texture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
	for(GLsizei y=0; y<height; y++)
	{
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y, width, 1, GL_RGB, GL_UNSIGNED_BYTE,
			pFrameRGB->data[0]+y*pFrameRGB->linesize[0]);
		GLenum err = glGetError();
		assert(err == GL_NO_ERROR);
	}

	glBindTexture(GL_TEXTURE_2D, 0);
	glFinish();
}

void VideoPlaybackEngine::updateALBuffer(ALuint buffer)
{
	if (buffer && !mAudioData.empty())
	{
		//convert if incompatible formats!!!!!!!!!!!!!!!!!!!
		alBufferData(buffer, mAudioFormat, &mAudioData[0], mAudioData.size(), pAudioCodecCtx->sample_rate);
		mAudioData.clear();
	}
}

void VideoPlaybackEngine::decodeVideoTask(GLuint texture, ALuint buffer, unsigned int& frameTime)
{
	AVPacket        packet;
	int frameFinished = 0;

	// Read frames and save first five frames to disk
	while(av_read_frame(pFormatCtx, &packet)>=0)
	{
		// Is this a packet from the video stream?
		if (packet.stream_index==audioStream)
		{
			//Should be aligned!!!!!!!!!!!!!!!!!!!!!
			char __declspec(align(16)) audioBuf[AVCODEC_MAX_AUDIO_FRAME_SIZE];
			int bufSize = AVCODEC_MAX_AUDIO_FRAME_SIZE;
			uint8_t*	inData = packet.data;
			int			inSize = packet.size;

			while(inSize > 0)
			{
				int processed = avcodec_decode_audio2(pAudioCodecCtx, (int16_t*)audioBuf, &bufSize, inData, inSize);

				if(processed < 0)
				{
					break;
				}

				inData += processed;
				inSize -= processed;

				if(bufSize > 0)
				{
					mAudioData.insert(mAudioData.end(), audioBuf, audioBuf+bufSize);
				}
			}
			av_free_packet(&packet);
		}
		if (packet.stream_index==videoStream)
		{
			//printf("packet pts=%I64d, dts=%I64d\n", packet.pts, packet.dts);
			// Decode video frame
			avcodec_decode_video(pVideoCodecCtx, pFrame, &frameFinished, packet.data, packet.size);

			// Did we get a video frame?
			if(frameFinished)
			{
				assert(packet.dts!=0x8000000000000000);
				//printf("Frame pts=%I64d, delay %d, pts_reop=%I64d\n", pFrame->pts, pFrame->repeat_pict, pFrame->reordered_opaque);
				//printf("frame finished\n");
				// Convert the image from its native format to RGB
				assert(pFrame->repeat_pict==0);
				frameTime = (unsigned int)(timeBase*packet.dts*1000);
				// Save the frame to disk
				av_free_packet(&packet);
				break;
			}
		}

		// Free the packet that was allocated by av_read_frame
		av_free_packet(&packet);
	}

	updateGLTexture(texture);
	updateALBuffer(buffer);
}