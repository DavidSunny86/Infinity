#include "VideoPlaybackEngine.h"
#include <cassert>

void VideoPlaybackEngine::init()
{
	// Register all formats and codecs
	av_register_all();
	// Open video file
	const char* videoFile = "F:\\Video\\Elfen_Lied_TV\\Elfen_Lied_TV_[01_of_13]_[ru_jp]_[Fafnir_&_AnimeReactor_Ru].mkv";
	if (av_open_input_file(&pFormatCtx, videoFile, NULL, 0, NULL)!=0)
		return; //Couldn't open file

	if (av_find_stream_info(pFormatCtx)<0)
		return; // Couldn't retrieve stream information(this is not media file or it is corrupted)
	
	// Dump information about file onto standard error
	dump_format(pFormatCtx, 0, videoFile, false);

	// Find the first video stream
	videoStream=-1;
	for(unsigned int i=0; i<pFormatCtx->nb_streams; i++)
		if(pFormatCtx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO)
		{
			videoStream=i;
			break;
		}
	if(videoStream==-1)
		return; // Didn't find a video stream

	// Get a pointer to the codec context for the video stream
	pCodecCtx=pFormatCtx->streams[videoStream]->codec;
	// Find the decoder for the video stream
	pCodec=avcodec_find_decoder(pCodecCtx->codec_id);
	if(pCodec==NULL)
		return; // Codec not found
	// Open codec
	if(avcodec_open(pCodecCtx, pCodec)<0)
		return; // Could not open codec
	// Hack to correct wrong frame rates that seem to be generated by some 
	// codecs
	// if(pCodecCtx->frame_rate>1000 && pCodecCtx->frame_rate_base==1)
	//    pCodecCtx->frame_rate_base=1000;

	// Allocate video frame
	pFrame=avcodec_alloc_frame();
	// Allocate an AVFrame structure
	pFrameRGB=avcodec_alloc_frame();
	if(pFrameRGB==NULL)
		return;

	// Determine required buffer size and allocate buffer
	numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx->width,
		pCodecCtx->height);
	buffer=new uint8_t[numBytes];

	// Assign appropriate parts of buffer to image planes in pFrameRGB
	avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,
		pCodecCtx->width, pCodecCtx->height);

	timeBase = av_q2d(pFormatCtx->streams[videoStream]->time_base);

	width = pCodecCtx->width;
	height = pCodecCtx->height;
	srcFormat = pCodecCtx->pix_fmt;
	dstFormat = PIX_FMT_RGB24;
	img_convert_ctx = sws_getContext(width, height, srcFormat, 
		width, height, dstFormat, SWS_BICUBIC, NULL, NULL, NULL);
}

void VideoPlaybackEngine::cleanup()
{
	sws_freeContext(img_convert_ctx);
	// Free the RGB image
	delete [] buffer;
	av_free(pFrameRGB);

	// Free the YUV frame
	av_free(pFrame);

	// Close the codec
	avcodec_close(pCodecCtx);

	// Close the video file
	av_close_input_file(pFormatCtx);
}

void VideoPlaybackEngine::updateGLTexture(GLuint texture)
{
	int realWidth = pFrameRGB->linesize[0];
	
	sws_scale(img_convert_ctx, pFrame->data, pFrame->linesize, 0, 
				height, pFrameRGB->data, pFrameRGB->linesize);

	glBindTexture(GL_TEXTURE_2D, texture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
	for(GLsizei y=0; y<height; y++)
	{
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y, width, 1, GL_RGB, GL_UNSIGNED_BYTE,
			pFrameRGB->data[0]+y*pFrameRGB->linesize[0]);
		GLenum err = glGetError();
		assert(err == GL_NO_ERROR);
	}

	glBindTexture(GL_TEXTURE_2D, 0);
	glFinish();
}

void VideoPlaybackEngine::decodeVideoTask(GLuint texture, unsigned int& frameTime)
{
	AVPacket        packet;
	int frameFinished = 0;

	// Read frames and save first five frames to disk
	while(av_read_frame(pFormatCtx, &packet)>=0)
	{
		// Is this a packet from the video stream?
		if(packet.stream_index==videoStream)
		{
			//printf("packet pts=%I64d, dts=%I64d\n", packet.pts, packet.dts);
			// Decode video frame
			avcodec_decode_video(pCodecCtx, pFrame, &frameFinished, packet.data, packet.size);

			// Did we get a video frame?
			if(frameFinished)
			{
				assert(packet.dts!=0x8000000000000000);
				//printf("Frame pts=%I64d, delay %d, pts_reop=%I64d\n", pFrame->pts, pFrame->repeat_pict, pFrame->reordered_opaque);
				//printf("frame finished\n");
				// Convert the image from its native format to RGB
				assert(pFrame->repeat_pict==0);
				updateGLTexture(texture);
				frameTime = (unsigned int)(timeBase*packet.dts*1000);
				// Save the frame to disk
				av_free_packet(&packet);
				break;
			}
		}

		// Free the packet that was allocated by av_read_frame
		av_free_packet(&packet);
	}
}